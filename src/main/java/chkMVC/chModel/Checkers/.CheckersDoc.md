<h1>
Checkers Documentation (Models)
</h1>

****

**BoardModel**

in a naive implementation of a board, one might declare a nxn vector of pieces, and move the pieces about as needed.
Although this technically works, it could cause larger issues with accessing out of bound areas.

So Instead the board model has a java Map<Position, AbstractPiece>, wherein the position has a specific hash function,
This makes it so putting a piece in say A1, will result in a warning from the class.

This also was very useful later, because we could pull out all the positions as a keyset,
and iterate through to display each piece.

In an ideal implementation, this would have also included a specfic Draw() function in each piece that could change the
display
based on other factors. (this would be extra useful in a chess game).

**CheckersGameModel**

As the name suggests, the game model, is less concerned with taking care of the pieces and all that comes with that. but
instead,
it handles the bigger picture things. It provides a nice way to abstract over the boardModel, and also keeps track of
things like
which team is expected to go.

**GameEventListener**

As the name suggests, this class provides the ability for the GameModel to later call on functions in countless places,
about general states in the game (such as when a piece has been removed, or when the game is over, etc.)

**PIECE_TEAM**

The Piece Team Enumeration is used to strongly type arguments, as to not rely on strings, which can be difficult to work
with in regards to servers.

**Position**

The Position Class Provides the most basic way to display where on the board
pieces are. As stated earlier, The Position class implements a specific Hash Function, relying on it's X and Y values
seperately to create a virtual board.
Apart from that, it also has a way to convert to string and back from string to position.
in some ways that might be a bad idea (what if we wanted to change how the board worked to support a 100 grid board?)